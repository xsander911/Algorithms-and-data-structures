/*
ID - 69216138

--ПРИНЦИП РАБОТЫ--
В данной задаче я хотел решить элегентно поиск, но не вышло, недодумал, если скажете додумать, додумаю, просто дедлайны.....
В чем суть! 
Массив отсортирован по возрастанию и сдвинут куда-то. 
Идея была проста, которая элегантная, я хотел найти разладку, тот индекс, где всё заканчивается и начинается массив. И далее использовать поиск
по кольцевому буфферу, типа я знаю индекс разладки и буду использовать все теже методы binarySearch, просто считаеть все элементы буду
l + shift, r + shift и %lenArray, чтобы не уходить за границы массива, а просто бегать по кругу. Но что-то не вышло, поэтому пошёл путём нименьшего сопротивления,
т.е. в лоб. 

1. Ищу разладку, также методом почти binarySearch -> searchRift();
	Смотрю больше левый элемент правого или нет, если нет, то больше ли правый элемент среднего элемента,тем самым
	определяю в какой половине это происходит. Если левый элемент меньше правого, то разладки нет, возвращаем 0 или rift.
	Далее если разладка есть, запоминаем наш rift = mid, если лево больше право и право больше mid,
	иначе rift будет элементом на 1 левее правой части, а левая часть будет mid, и уже ищем разладку в этой области.
2. Если разладки нет, то просто ищем бинарным поиском элемент в массиве. Если же разладка произошла, то мы определяем в какой половине
массива необходимо искать элемент, до разладки или после разладки. Вот и все дела

Как нагоню спринт, если успею)) то еще подумаю над методом с поиском по кольцу, как описан выше.
	
-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Бинарный поиск работает по сортированному массиву. Чтобы алгоритм отработал корректно в условиях нашей задачи, нам необходимо определить
диапазон поиска элемента. Диапазон должен быть отсортирован. Метод поиска разладки ищет элемент, который является началом массива, т.е. начала возрастающей
последовательности, далее мы сравниваем искомый элемент с началом вектора, значением вектора в индексе разладки и с концом вектора, тем самым определяя
его принадлежность диапазону, далее в нужно диапазоне возрастающей последовательности мы ищем элемент. 
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Сложность задачи сводится к двум методам searchRift и binarySearch_, оа метода работают за O(log(n)), быстрее наверное уже не придумать)
Cледовательно финальная сложность - O(log(n))
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Данный алгоритм не требует дополнительной памяти, так как все поиски осуществляются внутри массива, но рекурсивно. Единственное растет наш стеку,
по мере углубления в рекурсию. Но я использовал ссылки, так что избегаю ненужного копирования массива, когда ныряю вглубь.

Сложность O(n)
*/
#include <vector>
#include <cassert>
#include <cmath>

using namespace std;
using Iterator = std::vector<int>::iterator;
using CIterator = std::vector<int>::const_iterator;

int searchRift(const vector<int> &arr, int left, int right, int &rift) {

	int mid = (right + left) / 2;

	if (right <= left)
		return 0;
	
	if (arr[left] > arr[right] && arr[right] < arr[mid]) {
		rift = right - 1;
		right -= 1;
		left = mid;
		searchRift(arr, left, right, rift);
	}
	else if (arr[left] > arr[right] && arr[right] > arr[mid]) {		
		rift = mid;
		right = mid;
		searchRift(arr, left, right, rift);
	}
	else
		return rift;
	return rift;
}

/*
Входные данные:
 - arr - массив где будет происходить поиск элемента
 - value - элемент, который ищется в arr
 - left, right - левая правая граница поиска элемента
 - sequense - определяет в какой последовательности будет поиск: возрастающая или убывающая
	по дефолту для повзрастающей
	sequense < 0 - убывающая
	sequense > 0 возрастающая

 Возвращаемое значение:
 - индекс массива, в случае если элемент найден
 - если элемент не найден, вернётся -1
*/
int binarySearch_(const vector<int> &arr, int value, int left, int right, const int lenArr, int sequence = 1) {

	int mid = (left + right) / 2;

	if (right <= left)
		return -1;
	/*базовые случаи рекурсии, при которых необходимо завершить поиск*/
	if (arr[mid] == value)
		return mid;
	
	/*рекурсия*/
	if (sequence) {//для возрастающей последовательности
		if (value > arr[mid])	//если значение в массиве меньше искомого, то указываем новые границы от след элемента после мид и до конца массива (т.к. значение в правой части массива)
			return binarySearch_(arr, value, mid + 1, right, lenArr, sequence);
		else					//если значение больше искомого, то указываем новые границы начиная с начала массива до середины(т.к. значение в левой части массива)
			return binarySearch_(arr, value, left, mid, lenArr, sequence);
	}
	else {//для убывающей последовательности
		if (value < arr[mid])	//если значение в массиве меньше искомого(т.е. искомое больше), искомое в левой части массива
			return binarySearch_(arr, value, left, mid, lenArr, sequence);
		else					//если значение больше искомого, то в правой части 
			return binarySearch_(arr, value, mid + 1, right, lenArr, sequence);
	}
}

int broken_search(const std::vector<int>& vec, int k) {

	int rift = 0;
	int lenVec = vec.size();
	int i = 0;
	
	if (vec.size() == 1)
	{
		if (vec[0] == k)
			return 0;
		else
			return -1;
	}
	if (vec.size() == 2)
	{
		if (vec[0] == k)
			return 0;
		else if (vec[1] == k)
			return 1;
		else
			return -1;
	}

	rift = searchRift(vec, 0, vec.size() - 1, rift);

	if (rift) {

		if (k == vec[rift])
			return rift;
		else if(k >= vec[0] && k <= vec[rift - 1]){
			int idx = binarySearch_(vec, k, 0, rift, vec.size());
			return idx;
		}
		else {
			int idx = binarySearch_(vec, k, rift, vec.size(), vec.size());
			return idx;
		}
				
	}
	else {
		int idx = binarySearch_(vec, k, 0, vec.size(), vec.size());
		return idx;
	}
	
}

void test_() {
	std::vector<int> arr = { 19, 21, 100, 101, 1, 4, 5, 7, 12 };
	//std::vector<int> arr = { 7, 8, 9, 10, 1, 3, 5, 6 };
	//std::vector<int> arr = { 1,2,3,4,5,6,7,10,15,17 };
	//std::vector<int> arr = { 6, 7, 10, 0, 2, 4, 5 };
	//std::vector<int> arr = { 1, 2, 3, 5, 6, 7, 9, 0 };
	//int res = broken_search(arr, 5);
	assert(6 == broken_search(arr, 5));
}

//int main() {
//	test_();
//	/*int n;
//	int k;
//	cin >> n;
//	cin >> k;
//	int i = 0;
//	vector<int> arr(n);
//	for (i = 0; i < n; i++)
//		cin >> arr[i];
//	broken_search(arr, k);*/
//}