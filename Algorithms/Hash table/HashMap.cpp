/*
ID - 69449995

--ПРИНЦИП РАБОТЫ--

Решил немного утешить своё любопытство и отклонился от задания. Также у меня произошел феил, который я не могу объяснить. О нем скажу в конце, сполер
(закомментированный switch)

Надо было реазизовать Хеш таблицу, для целочесленных значений, с фиксированным размером ключей, использовать библиотечные решение нельзя(тут я использовать
решил немного отклониться от задания с целочесленным подходом :D), разрешать коллизии цепочкой или открытой адресацией, все операции в среднем O(1)

Реализовал следующим образом:

1) так как мы читаем команды (get,put,delete) и не используем map, решил заложить функционал генерации ключей по string
Для трех команд я выделил памяти под 3 элемента, но в итоге можно было и один :D об этом далее

В конструкторе я определяю какой тип ключа я буду использовать в объекте, для обработки строк передаем string и он инициализирует данные для
стрингов.
Методы для строк:
Для генерации полиномиального хеша используются переменные константы - R большое число, модуль которого будем брать от полиномаю, M - кол-во корзин
M, R, q должны быть простыми, для этого сделан метод
 GetSimpleNumber() вернет аргумент если он простой, или вернёт следующее по возрастанию простое число
 GetHash() - для строк мы будем использовать метод Горнера, чтобы посчитать наш полиномаю
 GornerSumm() - возвращает сумму полинома
 GetBucket() - для строк берем модуль от хеша
 put() - добавляем элемент:
	добавляем в корзину ключ и значение, вначало всегда, чтобы за O(1)
get() - выводит значение по ключу:
	работает чуть хитрее, смотрим пустали корзина, если пуста, то исключение бросаем
	если корзина не пуста, то мы бежим внутри корзины по списку, пока не наткнемся на искомый ключ и выводим его
delete() - не стал писать, так как особо и не требовалось) если надо будет, допишу
хотел вообще перегрузить [], чтобы как в map добавлять, но не умею еще работать с template
2) Теперь к основному заданию. Нам поступают команды, мы их обработали, теперь приступим к числам
Создаем объект с ключом int, параметры инициализации: P - количество бит, которое занимает число M, M - количество корзин
Генерация хеша будет методом умножения с использованием параметра alpha, которое подобрал сам Кнут! Но перейдём к адресной арифметике
Формулу описал в комментариях. S - альфа в целочесленном виде

Методы:

GetHash() возращает хеш, в нашем случае входной аргумент функции, так как число уже целое
GetBucket() считаем по формуле bucket(h) = (h * s mod 2^32) >> (32 - P), где P - степень 2-йки числа M = 2^P

Далее методы put, get, deleteKey
	put() - добавляем элемент:
	- проверяем пуста ли корзина, если корзина пуста, добавялем в начало листа ключ и значение
	- если корзина не пуста, тогда проверяем есть ли уже такой ключ, если есть, тогда обновляем значение, если нет, добавляем в начало новый узел
	get() - вернуть значение:
	-проверяем, есть ли что в корзине, если нет, вывозим исключение
	-если корзина не пуста, то бежимся по листу внутри и ищем ключ, который нужен, далее выводим
	delete() - удалить значение по ключу:
	-аналогичено с get(), проверяем корзину на пустоту, если пута, то исключение, если есть данные, то бежим внутри корзины в поисках ключа,
	при нахождении сохраняем значение в переменную, удаляем ключ и возвращаем значение

--ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Хеш генерится по всем канонам соответствующим "Свойствам" - так как используется адресная арифметика, то вычисляется она быстро
корзины будут заполняться равномерно, так как нашим методом значения по модулю генератся равновероятно от 0 до M - 1;

На этапе генерации хеша мы приложили большинство усилий, чтобы избежать коллизий.
Страховка: реализован метод обхода коллизий путем цепочек. Если у нас при двух разных ключах сгенерилась одна и та же корзина,
мы проверяем значения ключей корзин, так как мы храним эти ключи в списке, и если ключ есть, то мы обновим значение, а если нет, то добавим новое,
таким образом мы не теряем информацию.
Также при удалении, мы проверяем это по ключам, чтобы не удалить чужую запись.

--ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность в среднем будет O(n), как минимум на тесте.
Подробно:
Элементы добавляются в хеш таблицу за O(1) так как добавляем мы их вначало.
Поиск элемента и удаление в лучшем случае O(1), в худшем, если у нас много коллизий и ключ в конце списка, то O(n)
ну и надо следить за размером таблицы и данными, по отношению кол-ва эелементов на размер таблицы.
Если я задефайню SIZE_MAP 5, то у меня будет долго работать программа, если 100000 как по условию то быстро

Итого временная сложность: O(n)

--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пространственная сложность формируется из n ключей, и n коллизий, которые могут добавить n элементов к кажому ключу.
Средняя сложность при минимальном количестве коллизий O(n), в худшем случаем, O(n^2)

Итого пространственная сложность: O(n), O(n^2)

*/
#include <iostream>
#include <sstream>
#include <vector>
#include <list>
#include <cmath>
#define SIZE_MAP 100000
using namespace std;

class HashMap {
private:
	vector<list<pair<int, int>>> map;
	int M = 0;//количество корзин
	int P = 0;//степень числа M
	//alpha = 0.618033987;/*по велению Дональда*/
	long long S = 2654435769;	/*перевод alpha -> S = alpha * 2^32*/
public:
	HashMap(int n) {

		M = n;
		P = this->GetQuantityBitNumber(M);
		map.resize(M);

	}

	/*определяет простое ли число*/
	bool SimpleNumber(int n) {

		uint32_t i, len = sqrt(n) + 1;
		for (i = 3; i < len; i += 2) {
			if (n % i == 0)
				return false;
		}
		return true;
	}
	/*выдает простое число >= n && <= (n + 1)простое число*/
	int GetSimpleNumber(int n) {
		while (!SimpleNumber(n))
			n += 2;
		return n;
	}
	/*возвращает количество бит, которое требуется для числа*/
	int GetQuantityBitNumber(int number) {
		int degree_of_number = 1;
		while (number >>= 1)
			degree_of_number++;
		return degree_of_number;
	}
	/*в нашем случае число и будет являться хешом, т.к. по условию ключи - целый числа*/
	int GetHash(int key) { return key; }

	/*возвращает номер корзины*/
	int GetBucket(int hash) {
		/*bucket(h) = (h * s mod 2^32) >> (32 - P), где P - степень 2-йки числа M = 2^P*/
		long long mod = 1; mod <<= 32;
		int modM = 32 - this->P;
		long long temp = ((long long)hash * this->S) % mod;
		temp >>= modM;
		return (int)temp % this->M;
	}

	void put(int key, int value) {
		if (this->map[GetBucket(GetHash(key))].empty())
			this->map[GetBucket(GetHash(key))].push_front({ key, value });
		else {
			if (this->map[GetBucket(GetHash(key))].begin()->first == key)
				this->map[GetBucket(GetHash(key))].begin()->second = value;
			else
				this->map[GetBucket(GetHash(key))].push_front({ key, value });
		}

	}

	int get(int key) {

		if (this->map[GetBucket(GetHash(key))].empty()) {
			throw "None";
		}
		else {
			list<pair<int, int>>::iterator it = this->map[GetBucket(GetHash(key))].begin();
			while (it != this->map[GetBucket(GetHash(key))].end()) {

				if (it->first == key) {
					return it->second;
				}
				it++;
			}
			throw "None";
		}
	}

	int deleteKey(int key) {
		if (this->map[GetBucket(GetHash(key))].empty()) {
			throw "None";
		}
		else
		{
			list<pair<int, int>>::iterator it = this->map[GetBucket(GetHash(key))].begin();
			while (it != this->map[GetBucket(GetHash(key))].end()) {
				if (it->first == key) {
					int temp = it->second;
					this->map[GetBucket(GetHash(key))].erase(it);
					return temp;
				}
				it++;
			}
			throw "None";
		}
	}

};
unsigned constexpr const_hash(char const* input) {
	return *input ? static_cast<unsigned int>(*input) + 33 * const_hash(input + 1) : 5381;
}
int main() {
	int n = 0;
	cin >> n;
	if (n < 1 || n > 1000000)
		return 0;
	
	int key = 0, value = 0;
	string command = "";

	HashMap objMapEmployees(SIZE_MAP);

	for (int i = 0; i < n; i++) {

		try {
			cin >> command;

			switch (const_hash(command.c_str())) {
			case const_hash("put"):
				cin >> key;
				cin >> value;
				objMapEmployees.put(key, value);
				break;
			case const_hash("get"):
				cin >> key;
				cout << objMapEmployees.get(key) << endl;
				break;
			case const_hash("delete"):
				cin >> key;
				cout << objMapEmployees.deleteKey(key) << endl;
				break;
			default:
				break;
			}

		}
		catch (const char* error) {
			cout << error << endl;
		}
	}

	return 0;
}