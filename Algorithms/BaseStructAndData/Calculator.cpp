/*
ID - 68762482 (upd)
-- ПРИНЦИП РАБОТЫ --
В данной задаче рекомендуется использовать стек, что удобно.

- считываю строку символов, преобразую их в набор чисел и знаков, пишу в вектор
- создаю map(знак, указатель на функцию реализующую действия знака)
- запускаю цикл длиной в вектор (числа, символы)
- если число, то добавляю на стек
- если знак, проверяю размер стека. Если больше 1-го значения, значит применяю операцию символа 
{
	- достаю значение с вершины стека - это будет второй операнд second, удаляю значение с вершины стека
	- достаю следующее значение с вершины стека - это будет первый операнд first, удаляю значение свершины стека
	- передаю операнды в функцию операции знака, таким образомы, чтобы операция была -> first знак second
	- в операции с делением использовал функцию floor, чтобы выполнить условия задания (если так нельзя, тогда подумаю как написать ручное округление)
	- записываю результат на вершину стека (что я конечно считаю ошибкой, по хорошему обработать бы этот случай, если последовательность заканчивается
	  числами без знаков, а до этого была совершена операция, тогда выводить последний результат, или если операций не было - последнее число на стеке)

}
- если в стеке <= 1 значения, то пропускаем итерацию, таким образом избегаем случаев когда будут ошибочные последовательности знаков
- после цикла выводим вершину стека

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

значения добавляются последовательно, после операций промежуточные значения удаляются и сохраняется только результат, такой метод 
чем-то напоминает рекурсию))) (можно делать операции вида (2 + 2) * (2 + 2) и тд.)
следовательно либо у нас будут выполняться полседовательные операции и при корректном вводе знаков выводиться результат этих операций,
либо будет выводиться последнее число на стеке
не буду вносить это в код, вдруг Вы не одобрите, опишу логику здесь:
вводим счетчик idx, который будет записывать size стека каждый раз, когда на вершину кладётся результат
в конце работы цикла, когда мы хотим вывести значение, мы проверям
если(размер стека > idx и idx != 0) то мы удаляем элементы (размер стека - idx) раз и выводим тот, который был последним результатом на стеке, т.е. idx 

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Добавить элемент в стек	-	O(1)
Удалить элемент из стека -	O(1)
Проверить размер -			O(1) (мы ведь можем фиксировать размер при добавлении и удалении :D надеюсь я не ошибся :D )

Общая сложность будет O(n) - где n это колчичество итераций цикла(колическо операндов и знаков, которые нам необходимо обойти)

Сложность в среднем
O(n) / n ~ O(1)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Мы используем структуру данных стек

памяти у нас уйдет sizeof(stack) * количество чисел, в худшем случаем, если будут только числа, тогда памяти у нас уйдёт
O(n)

*/

#include <iostream>
#include <sstream>
#include <cmath>
#include <string>
#include <vector>
#include <map>
#include <stack>

using namespace std;

typedef int(*operation)(int, int);

vector<string> split(string& s, char delimeter)
{
	stringstream ss(s);
	string item;
	vector<string> tokens;
	while (getline(ss, item, delimeter))
	{
		tokens.push_back(item);
	}
	return tokens;
}

int main() {

	string data;
	getline(cin, data);

	if (data.empty())
		return 0;

	vector<string> tokens = split(data, ' ');
	int len = tokens.size(), i = 0;
	stack<int> numbers;
	int first, second;
	map<string, operation> instructions;
	instructions["+"] = [](int a, int b) {return a + b; };
	instructions["-"] = [](int a, int b) {return a - b; };
	instructions["/"] = [](int a, int b) {
		if (b == 0)
			return 0;
		return (int)floor(a / (b + 0.));
	};
	instructions["*"] = [](int a, int b) {return a * b; };

	for (i = 0; i < len; i++) {

		auto function = instructions.find(tokens[i]);

		if (function == instructions.end()) {
			numbers.push(stoi(tokens[i]));
		}
		else if (numbers.size() > 1) {
			second = numbers.top();
			numbers.pop();
			first = numbers.top();
			numbers.pop();
			numbers.push(function->second(first, second));
		}
	}
	cout << numbers.top() << endl;
}