/*
ID - 68762085 (upd)
--ПРИНЦИП РАБОТЫ--

ДЕК я реализовывал с помощью кольцевого буффера(как было рекомендовано в задании)

В ДЕКе можно добавлять элементы в начало и конец, также можно их доставать с начала и конца

Самая простая идея, которая у меня возникла - это использовать два массива:
в первом массиве мы будем следить за элементами, которые надо добавить в конец(push_back) и вытащить начало (pop_front)
воторой массив мы бы заполняли реверсивно. Когда необходимо достать pop_front мы бы доставали из первого массива head,
когда надо достать pop_back мы бы доставали head из второго массива, удаляя соответствующие элементы в обоих массивах и сдвигая
head и tail. Но данный метод займет в два раза больше памяти, поэтому я решил реализовать ДЕК на одном массиве.

Чтобы реализовать ДЕК на одном массиве, мне надо заставить ходить head и tail не только по часовой стрелке, но и против нее.
Например, если я хочу добавить элемент методом push_front, тогда head должен двигаться против часовой стрелки, чтобы вставить элемент
перед первым добавленным. Посчитать индекс массива против часовой стрелки можно следующим образом:
***
head = (head - 1 + max_size) % max_size; здесь я прибавляю max_size, потому что если мы будем считать остаток от отрицательно числа, то
мы можем в какой-то момент получить не то, что ожидаем, а также, если мы идем против часовой стрелки, то мы должны получать индексы
массива, которые идут на убывание (size = 5 -> .. 2 1 0 4 3 2 1 0 ..), следовательно деинкрементируя head и прибавляя к нему max_size,
мы разворачиваем стрелки часов :)
-
аналогично в методе pop_back() мы должны считать tail, так как вытаскивая последний элемент, мы должны сдвинуть tail назад
***
В методе pop_front() мы сдвигаем head по часовой стрелке: head = (head + 1) % max_size;
Также в методе push_back мы сдвигаем tail = (tail + 1) % max_size;

Параллельно мы следим за размером size:
- чтобы следить за заполнением ДЕК
- избежать пересечения head и tail
- чтобы определить пуст ли дек
- когда дек пуст, мы обнуляем значения tail и head, чтобы вернуть их в начало массива. (технически они должны совпасть, когда size = 0,
поэтому можно не обнулять tail и head, это сделано на моё усмотрение)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

ДЕК добавляет и извлекает элементы с обоих концов
- при добавлении в начало, head двигается против часовой стрелки, добавляет элемент и фиксирует size
- при добавлении в конец, tail добавляет элемент, двигается по часовой стрелке и фиксирует size
- head и tail не пересекутся при записи, так как их инкрементация фиксируется size, так же они не выйдут за пределы массива,
так как реализована методология кольцевого буффера
- head фиксирует начало ДЕКа
- tail фиксирует конец ДЕКа
- сумма операций tail и head не превосходят значение size
- при выводе первого элемента, head сдвигается на 1 элемент назад и фиксирует новый первый элемент ДЕКа
- при выводе последнего элемента, tail сдвигается на 1 элемент назад и фиксирует новый последний элемент ДЕКа

следовально элементы выводятся в нужной для ДЕК последовательности и когда size = 0, то head и tail больше не двигаются

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Выделение памяти, если оно использует memset(0) - O(n)
Добавление элемента в конец или начало ДЕК - O(1), так как мы используем массив и точно знаем индекс, по которому добавляем элементы.
После добавления мы знаем индекс куда добавлять новый элемент.
Вывод и удаление первого или последнего элемента - O(1), так как мы фиксируем их индексы в массиве.
После удаления мы знаем новый индекс элемента, который надо вывести и удалить.

в целом, если мы всё добавим и всё удалим, общая сложность будет O(n)

Сложность в среднем
Добавление и извлечение будет в сумме O(n) раз
O(n)/n ~ O(1)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В моем случаем, ДЕК реализован с помощью одного массива, следовательно,
если мы используем n элементов, то мы займём O(n) памяти.

*/

#include <iostream>
#include <string>
#include <map>
#include <algorithm>
#include <vector>
#include <sstream>

using namespace std;

namespace DecCustom {

	class Dec {

	private:
		int head;
		int tail;
		int inputSize;		//size array
		int size;			//size filled dec
		vector<int> dec;
	public:
		Dec(int m) {
			inputSize = m;
			dec.resize(inputSize);
			head = 0;
			tail = 0;
			size = 0;
		}

		void push_front(int value) {

			if (size < inputSize) {
				head = (head - 1 + inputSize) % inputSize;
				dec[head] = value;
				size += 1;
			}
			else
				throw "error";
		}

		void pop_front() {

			int valueDec = 0;

			if (size != 0) {

				valueDec = dec[head];
				dec[head] = 0;
				head = (head + 1) % inputSize;
				size -= 1;
				cout << valueDec << endl;

			}
			else
				throw "error";
		}

		void push_back(int value) {

			if (size < inputSize) {
				dec[tail] = value;
				tail = (tail + 1) % inputSize;
				size += 1;
			}
			else
				throw "error";
		}

		void pop_back() {

			int valueDec = 0;

			if (size != 0) {
				tail = (tail - 1 + inputSize) % inputSize;
				valueDec = dec[tail];
				dec[tail] = 0;
				size -= 1;
				cout << valueDec << endl;
			}
			else
				throw "error";
		}

	};
}

int main() {

	int n, m;

	cin >> n;
	if (n < 0 || n > 100000)
		return 0;
	cin >> m;
	if (m < 0 || m > 50000)
		return 0;

	DecCustom::Dec objDec = { m };

	string command = "";
	int value = 0;
	map<string, int> instructions;
	instructions["push_front"] = 0;
	instructions["pop_front"] = 1;
	instructions["push_back"] = 2;
	instructions["pop_back"] = 3;

	while (n) {

		cin >> command;
		try {
			switch (instructions[command])
			{
			case 0://push_front()
				cin >> value;
				objDec.push_front(value);
				break;
			case 1://pop_front()
				objDec.pop_front();
				break;
			case 2://push_back
				cin >> value;
				objDec.push_back(value);
				break;
			case 3://pop_back
				objDec.pop_back();
				break;
			default:
				break;
			}
		}
		catch (const char* error) {
			cout << error << endl;
		}
		n -= 1;
	}
}
