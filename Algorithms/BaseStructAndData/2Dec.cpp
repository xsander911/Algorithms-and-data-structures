/*
ID - 68761949 (upd)
--ПРИНЦИП РАБОТЫ--

В ДЕКе можно добавлять элементы в начало и конец, также можно их доставать с начала и конца

1 метод на двух массивах

Чтобы реализовать ДЕК на двух массивах придётся выделить в два раза больше памяти и следить за бОльшими моментами)

- необходимо два массива. Первый массив будет отвечать за заполнение push_front, второй за заполнение push_back
- необходимо следить чтобы заполнение каждого массива не превосходило разность между общим размером ДЕКа и другого массива (отсюда два размера заполнения частей дека)
т.е. при заполнении одного из массивов должно соблюдаться условие sizeX < max_size - sizeY, и наоборот (ну или sizeX + sizeY < max_size, так мб и удобнее для читабельности)
- для двух массивов у нас объявляются headFront, headBack и tailFront, tailBack (инициализируются нулём)

- когда мы хотим добавить элемент push_front, мы проверяем условие заполнения, добавляем элемент по индексу tailFront и сдвигаем его по часовой стрелке(вперед)
- когда мы хотим добавить элемент push_back, мы проверяем условие заполнения, добавляем элемент по индексу tailBack и сдвигаем его по часовой стралке(вперед)
- (начинается свистопляска :D )
- чтобы достать элемент методом pop_front:
	- провермяем не пуст ли наш массив Front
		- если не пуст, то мы возвращаем назад(декрементируем) наш индекс tailFront, двигаем его против часовой стрелки, так как он всегда на шаг впереди после добавления элемента
		- выводим элемент
		- уменьшаем размер массива Front
	- если пуст, то проверяем не пуст ли второй массив Back
		- если не пуст, то мы берем его начало через индекс headBack(так как начало бэка - первый элемент, аналогичено и с началом Front - последний элемент)
		- выводим, обнуляем значение массива
		- далее сдвигаем headBack на шаг вперед(по часовой), далее сравниваем с tailBack, если они совпадают, значит массив Back пуст и надо обнулить наши индексы, во избежание нарушения порядка заполнения данных. Не забываем, что tail всегда на шаг впереди при добавлении, но когда мы удаляем элемент, tail находится на той позиции, где был удалён элемент, а если мы удаляем эелементы с начала массива, то head после удаления смотрит на следующий шаг. Поэтому мы должны проверять это условие в тот момент, когда выводим элементы через head, чтобы после удаления проверить не пуст ли следующий элемент(tail всегда указывает на пустой элемент). Если head после удаления совпадает c tail - это означает что наш массив пуст и надо начинать заполнение сначала.
		- если head и tail совпадают - обнуляем их
		- уменьшаем размер массива Back
	- если тоже пуст, то выводим "error", так как ДЕК пуст
-чтобы достать элемент методом pop_back, делаем аналогично, только зеркально
	- проверяем не пуст ли массив Back
		- если не пуст, то декрементируем индекс tailBack
		- выводим элемент
		- уменьшаем размер массива Back
	- если пуст, то проверяем не пуст ли массив Front
		-если не пуст, то берем эелемент по индексу headFront
		- выводим, обнуляем значение массива
		- сдвигаем headFront вперед(по часовой), далее сравниваем его с tailFront
		- если tail и head совпадают - обнуляем
		- уменьшаем размер массива Front
	- если тоже пуст, то выводим "error", так как ДЕК пуст


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

- добавление элементов:
 когда мы добавляем эелементы в два массива, то мы следим за суммой добавленных элементов и проверяем с размером ДЕКа, следовательно больше чем размер ДЕКа мы данных добавить не сможем

- вывод элементов:
 перед выводом элементов мы проверяем не пусты ли оба массива, следовательно если массивы пусты, то мы не выведем лишнюю информацию и сообщим о том, что ДЕК пуст

 для метода pop_front мы сначала проверяем массив Front, который хранит элементы добавленных на перед ДЕКа, если массив не пуст, то мы выводим последний элемент в массиве,
 так как он является последним добавленным в начало ДЕКа, следовательно мы выводим самый первый элемент ДЕКа, что соответствует принципам работы ДЕК
 если массив Front пуст, то мы проверяем массив Back. Если он не пуст, то мы выводим первый его эелемент, так как в этом случае он является началом ДЕКа, потому что элементы добавляются
 по принципу СТЕКа, следовательно мы снова выведем самый первый элемент ДЕКа, что соответствует принципам работы ДЕК

 для метода pop_back мы проводим аналогичные проверки, только уже начинаем с массива Back, который хранит элементы добавленные в конец ДЕКа. Если Back не пуст, то мы выводим последний
 элемент массива Back, так как он является последним добавленным в конец ДЕКа, следовательно мы выводим последний элемент ДЕКа, что соответствует принципам работы ДЕК
 если массив Back пуст, то мы проверяем массив Front. Если он не пуст, то мы выводим первый его элемент, так как для Front это был самый первый добавленный элемент, а значит последний для него, который он бы вывел. Следовательно в таком случае мы выводим последний элемент ДЕКа, что соответствует принципам работы ДЕК

 все операции контролируются размерами, а также здесь присутствует реализация кольцевого буффера, что позволяет избежать выходы за пределы массива

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Добавление/удаление элемента происходит за O(1), так как мы обращаемся по индексам массива

Если взять весь обход в худших случаях у нас будет:
1 полностью заполнить массив Front и Вывести его O(n) и O(n) операций, следовательно сложность O(n)
2 полностью заполнить массив Back ==//==, ==//== O(n)
3 частично заполнить Front и Back, также вывести их, O(n-back) O(back) также в сумме дадут O(n)

Амортизация = общее кол-во операций / размер входных данных = O(n) / n ~ O(1)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

В данном методе используется в два раза больше памяти чем в методе на 1 массиве, но пространственная сложность не меняется
O(n) + O(n) = O(n) (но если мы обратимся к embedded, то тут уже ваша пространственная сложность не работает :D )

*/

#include <iostream>
#include <string>
#include <map>
#include <algorithm>
#include <vector>
#include <sstream>

using namespace std;

namespace DecCustom {

	class Dec {

	private:
		int headFront;
		int headBack;
		int tailFront;
		int tailBack;
		int inputSize;		//size array	
		int sizeFront;		//size filled dec
		int sizeBack;		//size filled dec
		vector<int> decFront;
		vector<int> decBack;
	public:
		Dec(int m) {
			inputSize = m;
			decFront.resize(inputSize);
			decBack.resize(inputSize);
			headFront = 0;
			headBack = 0;
			tailFront = 0;
			tailBack = 0;
			sizeFront = 0;
			sizeBack = 0;
		}

		void push_front(int value) {

			if (sizeFront < inputSize - sizeBack) {
				decFront[tailFront] = value;
				tailFront = (tailFront + 1) % inputSize;
				sizeFront += 1;
			}
			else
				throw "error";

		}

		void push_back(int value) {

			if (sizeBack < inputSize - sizeFront) {
				decBack[tailBack] = value;
				tailBack = (tailBack + 1) % inputSize;
				sizeBack += 1;
			}
			else
				throw "error";

		}
		void pop_front() {

			int valueDec = 0;

			if (sizeFront > 0) {

				tailFront = (tailFront - 1 + inputSize) % inputSize;
				valueDec = decFront[tailFront];
				decFront[tailFront] = 0;
				sizeFront -= 1;
				cout << valueDec << endl;

			}
			else if (sizeBack > 0) {

				valueDec = decBack[headBack];
				decBack[headBack] = 0;
				headBack = (headBack + 1) % inputSize;
				if (headBack == tailBack) {
					headBack = 0;
					tailBack = 0;
				}
				sizeBack -= 1;
				cout << valueDec << endl;

			}
			else
				throw "error";

		}

		void pop_back() {

			int valueDec = 0;

			if (sizeBack > 0) {

				tailBack = (tailBack - 1 + inputSize) % inputSize;
				valueDec = decBack[tailBack];
				decBack[tailBack] = 0;
				sizeBack -= 1;
				cout << valueDec << endl;

			}
			else if (sizeFront > 0) {
				valueDec = decFront[headFront];
				decFront[headFront] = 0;
				headFront = (headFront + 1) % inputSize;
				if (headFront == tailFront) {
					headFront = 0;
					tailFront = 0;
				}
				sizeFront -= 1;
				cout << valueDec << endl;
			}
			else
				throw "error";

		}

	};
}

int main() {

	int n, m;

	cin >> n;
	if (n < 0 || n > 100000)
		return 0;
	cin >> m;
	if (m < 0 || m > 50000)
		return 0;

	DecCustom::Dec objDec = { m };

	string command = "";
	int value = 0;
	map<string, int> instructions;
	instructions["push_front"] = 0;
	instructions["pop_front"] = 1;
	instructions["push_back"] = 2;
	instructions["pop_back"] = 3;

	while (n) {

		cin >> command;
		try {
			switch (instructions[command])
			{
			case 0://push_front()
				cin >> value;
				objDec.push_front(value);
				break;
			case 1://pop_front()
				objDec.pop_front();
				break;
			case 2://push_back
				cin >> value;
				objDec.push_back(value);
				break;
			case 3://pop_back
				objDec.pop_back();
				break;
			default:
				break;
			}
		}
		catch (const char* error) {
			cout << error << endl;
		}
		n -= 1;
	}
	return 0;
}
